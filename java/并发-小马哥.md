# 并发类的面试

## 线程创建

>有哪些方法创建线程

创建有且只有一个new Thread()
运行线程有两种 -> Runnable.run() & Thread.start()

```java
public static void main(String[] args) {
    // main 线程 -> 子线程
    Thread t = new Thread(() -> {}, "subThread-1");
}

```

>如何创建进程

```java
public static void main(String[] args) {
    // 获取Java Runtime
    Runtime runtime = Runtime.getRuntime();
    Process process = runtime.exec("calc");
    process.exitValue();
}
```

>如何销毁一个线程

```java
public static void main(String[] args) {
    // main 线程 -> 子线程
    Thread t = new Thread(() -> {
        System.out.printf("thread [%s] is running\n", Thread.currentThread().getName());

    }, "subThread-1");
    // 启动线程
    t.start();
    System.out.printf("thread [%s] is alive: %s\n", t.getName(), t.isAlive());
    // 在java中, 执行线程java是没有办法销毁它的,
    // 但是当Thread.isAlive()返回false时, 实际底层的thread已经被销毁了
}
```

## 线程执行

>如何通过JAVA API启动线程

```java
thread.start()
```

> 如何让线程顺序执行

在线程start()之后立刻join()

```java
public static void main(String[] args) {
    Thread t1 = new Thread(Demo::action, "t1");
    Thread t2 = new Thread(Demo::action, "t2");
    Thread t3 = new Thread(Demo::action, "t3");
    // start() 仅是通知线程启动, 不保证执行顺序
    t1.start();
    t2.start();
    t3.start();
    // join() 控制线程必须执行完成, 不保证执行顺序
    t1.join();
    t2.join();
    t3.join();
    // start() + join() 可以保证执行顺序
    t1.start();
    t1.join();
}

private static void action() {
    System.out.printf("Thread[%s] is running...\n", Thread.currentThread().getName());
}
```

>其他的实现方式

```java

    Thread t1 = new Thread(Demo::action, "t1");
    Thread t2 = new Thread(Demo::action, "t2");
    Thread t3 = new Thread(Demo::action, "t3");
private static void threadLoop() {
    t1.start();
    while(t1.isAlive()) {
        // 自旋 self Spin
    }
    t2.start();
    while(t2.isAlive()) {}
    t3.start();
    while(t3.isAlive()) {}
}
private static void threadSleep() {
    t1.start();
    while(t1.isAlive()) {
        // sleep
        Thread.sleep(0);
    }
    t2.start();
    while(t2.isAlive()) {
        Thread.sleep(0);
    }
    t3.start();
    while(t3.isAlive()) {
        Thread.sleep(0);
    }
}
private static void threadWait() {
    threadStartAndWait(t1);
    threadStartAndWait(t2);
    threadStartAndWait(t3);
}

private static void threadStartAndWait(Thread t) {
    if (Thread.State.New.equals(t.getState())) {
        t.start();
    }
    while (t.isAlive()) {
        synchronized (t) {
            try {
                t.wait(); // 谁通知了Thread -> thread.notify
            } catch(InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

```

## 线程中止

>如何停止一个线程? (没办法停止线程, 只能停止逻辑)

```java
public static void main(String[] args) {
    Action a = new Action();
    Thread t = new Thread(a, "t1");
    t.start();
    a.setStopped(true);
    t.join();

    Thread t2 = new Thread(() -> {
        if (!Thread.currentThread().isInterrupted()) {
            action();
        }
    }, "t2");
    t2.start();
    // 中断操作 (仅仅设置状态, 而并非中止线程)
    t2.interrupt();
    t2.join();
}

private static class Action implements Runnable {
    // 线程安全问题, 确保可见性 Happen-Before
    private boolean stopped = false;

    @override
    public void run(){
        if (!stopped) {
            action();
        }
    }

    public void setStopped(boolean stopped) {
        this.stopped = stopped;
    }
}

public static void action() {
    System.out.printf("Thread [%s] is running..", Thread.currentThread().getName());
}
```

>为什么JAVA放弃了Thread的stop方法

Inherently unsafe, 为了防止死锁, 状态不一致
Stopping a thread causes it to unlock all the monitors that it has locked.(The monitors are unlocked as the ThreadDeath exception propagates up the stack)

>Thread interrupt(), isInterrupted()以及interrupted()的区别和意义

- interrupt 设置线程状态
- isInterrupted 仅判断不清除
- interrupted() 判断&清除

## 线程异常

>当线程遇到异常时, 到底发生了什么?

```java
public static void main(String[] args){
    Thread t = new Thread(() -> {
        throw new RuntimeException("eee");
    }, "t1");
    t1.start();
    t1.join();

    // java里的THread是一个包装, 由GC做垃圾回收
    // JVM Thread 可能是一个OS Thread, JVM管理, 当线程执行完毕(正常或异常)
    System.out.print(t1.isAlive()); // false (t1的对象还在, 线程已经终止了)
}
```

>当线程遇到异常时, 如何捕获?

```java
public static void main(String[] args){
    Thread.setDefaultUncaughtExceptionHandler((t, throwable) -> {
        System.out.printf("Thread [%s] runs with err, %s", t.getName(), throwable.getMessage());
    })
    Thread t = new Thread(() -> {
        throw new RuntimeException("eee");
    }, "t1");
    t1.start();
    t1.join();

    System.out.print(t1.isAlive()); // false
}
```

>当线程遇到异常时, ThreadPoolExecutor如何捕获异常?

```java
public static void main(String[] args){
    ExecutorService service = Executors.newFixedThreadPool(2);
    ThreadPoolExecutor executor = new ThreadPoolExecutor(
        1,1,0,TimeUnit.SECONDS, new LinkedBlockingQueue()
    ) {
        // 通过覆盖afterExecute达到获取异常的信息
        @Override
        protected void afterExecute(Runnable r, Throwable t) {
            System.out.printf("Thread [%s] runs with err, %s", Thread.currentThread().getName(), t.getMessage());
        }
    }
    service.execute(()-> {
        throw new RuntimeException("eee");
    });

    // 等待一秒钟, 确保提交的任务完成
    service.awaitTermination(1, TimeUnit.SECONDS);
    // 关闭线程池
    service.shutdown();
}
```
