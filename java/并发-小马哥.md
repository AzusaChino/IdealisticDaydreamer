# 并发类的面试

## 线程创建

>有哪些方法创建线程

创建有且只有一个new Thread()
运行线程有两种 -> Runnable.run() & Thread.start()

```java
public static void main(String[] args) {
    // main 线程 -> 子线程
    Thread t = new Thread(() -> {}, "subThread-1");
}

```

>如何创建进程

```java
public static void main(String[] args) {
    // 获取Java Runtime
    Runtime runtime = Runtime.getRuntime();
    Process process = runtime.exec("calc");
    process.exitValue();
}
```

>如何销毁一个线程

```java
public static void main(String[] args) {
    // main 线程 -> 子线程
    Thread t = new Thread(() -> {
        System.out.printf("thread [%s] is running\n", Thread.currentThread().getName());

    }, "subThread-1");
    // 启动线程
    t.start();
    System.out.printf("thread [%s] is alive: %s\n", t.getName(), t.isAlive());
    // 在java中, 执行线程java是没有办法销毁它的,
    // 但是当Thread.isAlive()返回false时, 实际底层的thread已经被销毁了
}
```

## 线程执行

>如何通过JAVA API启动线程

```java
thread.start()
```

> 如何让线程顺序执行

在线程start()之后立刻join()

```java
public static void main(String[] args) {
    Thread t1 = new Thread(Demo::action, "t1");
    Thread t2 = new Thread(Demo::action, "t2");
    Thread t3 = new Thread(Demo::action, "t3");
    // start() 仅是通知线程启动, 不保证执行顺序
    t1.start();
    t2.start();
    t3.start();
    // join() 控制线程必须执行完成, 不保证执行顺序
    t1.join();
    t2.join();
    t3.join();
    // start() + join() 可以保证执行顺序
    t1.start();
    t1.join();
}

private static void action() {
    System.out.printf("Thread[%s] is running...\n", Thread.currentThread().getName());
}
```

>其他的实现方式

```java

    Thread t1 = new Thread(Demo::action, "t1");
    Thread t2 = new Thread(Demo::action, "t2");
    Thread t3 = new Thread(Demo::action, "t3");
private static void threadLoop() {
    t1.start();
    while(t1.isAlive()) {
        // 自旋 self Spin
    }
    t2.start();
    while(t2.isAlive()) {}
    t3.start();
    while(t3.isAlive()) {}
}
private static void threadSleep() {
    t1.start();
    while(t1.isAlive()) {
        // sleep
        Thread.sleep(0);
    }
    t2.start();
    while(t2.isAlive()) {
        Thread.sleep(0);
    }
    t3.start();
    while(t3.isAlive()) {
        Thread.sleep(0);
    }
}
private static void threadWait() {
    threadStartAndWait(t1);
    threadStartAndWait(t2);
    threadStartAndWait(t3);
}

private static void threadStartAndWait(Thread t) {
    if (Thread.State.New.equals(t.getState())) {
        t.start();
    }
    while (t.isAlive()) {
        synchronized (t) {
            try {
                t.wait(); // 谁通知了Thread -> thread.notify
            } catch(InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

```
