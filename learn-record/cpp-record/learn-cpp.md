# CPP学习

## 变量和基本类型

### 基本内置类型

- 算术类型(arithmetic type)：整型（integral type, 包括字符和布尔型）和浮点型
- 空类型(void)

#### 如何选择类型

- 当明确知晓数值不可能为负时，选用无符号类型
- 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果数值超过了int的范围，可以选用long long。
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。
- 执行浮点数运算时选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。

#### 字面值常量

- 20 十进制
- 024 八进制
- 0x13 十六进制

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是int、long和long long中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型short没有对应的字面值。

> 切勿混用带符号类型和无符号类型

### 变量

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

#### 变量定义

变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。`std:string book("0-201-78345-X")`

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。

#### 四种初始化

```cpp
int a = 0;
int b = {0};
int c{0};
int d(0);
```

### 复合类型

#### 引用

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。

```c++
int iVal = 1024;
int &refVal = ival; // refVal指向ival
int &refVal;
```

#### 指针

指针（pointer）是“指向（point to）”另外一种类型的复合类型。

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

```c++
// 指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）
int iVal = 42;
int *p = &iVal; // p存放变量iVal的地址，或者说p是指向变量iVal的指针
```

##### 指针值

指针的值（地址）应属下列4种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况以外的其他值

##### 某些符号有多重含义

像&和＊这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：

```c++
int i = 42;
int &r = i; // ref
int *p; // ptr
p = &r; // 取地址符
*p = i; // 解引用符
int &r2 = *p; // &是声明的一部分，*是解引用符
```

空指针（nullptr）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空

```c++
int *p1 = nullptr; // 等价于 int *p1 = 0;
int *p2 = 0; // 直接将p2初始化为字面常量0
// 需要 #include <cstlib>
int *p3 = NULL;
```

##### void* 指针

`void*`是一种特殊的指针类型，可用于存放任意对象的地址。

##### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i = 42;
int *p; // p是一个int型指针
int *&r = p; // r是一个对指针p的引用
r = &i; // r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0; // 解引用r得到i，也就是p指向的对象，将i的值改为0
```

### const限定符

关键字const定义常量，const对象一旦创建后其值就不能再改变，因此const对象必须初始化。

```c++
int i = 42;
const ci = i; // 可行，i的值被拷贝给了ci
int j = ci; // 可行，ci的值被拷贝给了j
```

#### 默认情况下，const对象仅在文件内有效

编译器将在编译过程种把用到该变量的地方都替换成对应的值。  
如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。  
如果想在多文件中使用同一个常量，不管是声明还是定义都添加extern关键字。

#### const的引用

```c++
const int ci = 1024;
const int &r1 = ci; // 正确，引用及其对应的对象都是常量

r1 = 42; // 错误，r1是对常量的引用
int &r2 = ci; // 错误，试图让一个非常量引用指向一个常量对象

int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上
const int &r2 = 42; // 正确
const int &r2 = r1 * 2; // 正确
int &r4 = r1 * 2; // 错误，r4是一个普通的非常量引用
```
